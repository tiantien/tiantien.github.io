(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{319:function(e,s,t){"use strict";t.r(s);var a=t(5),l=Object(a.a)({},(function(){var e=this,s=e._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"statefulset"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#statefulset"}},[e._v("#")]),e._v(" StateFulSet")]),e._v(" "),s("h2",{attrs:{id:"概述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[e._v("#")]),e._v(" 概述")]),e._v(" "),s("p",[e._v("Deployment控制器下的Pod都有个共同特点，那就是每个Pod除了名称和IP地址不同，其余完全相同。需要的时候，Deployment可以通过Pod模板创建新的Pod；不需要的时候，Deployment就可以删除任意一个Pod。")]),e._v(" "),s("p",[e._v("但是在某些场景下，这并不满足需求，比如有些分布式的场景，要求每个Pod都有自己单独的状态时，比如分布式数据库，每个Pod要求有单独的存储，这时Deployment就不能满足需求了。")]),e._v(" "),s("p",[e._v("详细分析下有状态应用的需求，分布式有状态的特点主要是应用中每个部分的角色不同（即分工不同），比如数据库有主备，Pod之间有依赖，对应到Kubernetes中就是对Pod有如下要求：")]),e._v(" "),s("ul",[s("li",[e._v("Pod能够被别的Pod找到，这就要求Pod有固定的标识。")]),e._v(" "),s("li",[e._v("每个Pod有单独存储，Pod被删除恢复后，读取的数据必须还是以前那份，否则状态就会不一致。")])]),e._v(" "),s("p",[e._v("Kubernetes提供了StatefulSet来解决这个问题，其具体如下：")]),e._v(" "),s("ol",[s("li",[e._v("StatefulSet给每个Pod提供固定名称，Pod名称增加从0-N的固定后缀，Pod重新调度后Pod名称和HostName不变。")]),e._v(" "),s("li",[e._v("StatefulSet通过Headless Service给每个Pod提供固定的访问域名，Service的概念会在后面章节中详细介绍。")]),e._v(" "),s("li",[e._v("StatefulSet通过创建固定标识的PVC保证Pod重新调度后还是能访问到相同的持久化数据。")])]),e._v(" "),s("h2",{attrs:{id:"statefulset-使用场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#statefulset-使用场景"}},[e._v("#")]),e._v(" StatefulSet 使用场景")]),e._v(" "),s("p",[e._v("对于有如下要求的应用程序，StatefulSet 非常适用：")]),e._v(" "),s("ul",[s("li",[e._v("稳定、唯一的网络标识（dnsname）")]),e._v(" "),s("li",[e._v("每个Pod始终对应各自的存储路径（PersistantVolumeClaimTemplate）")]),e._v(" "),s("li",[e._v("按顺序地增加副本、减少副本，并在减少副本时执行清理")]),e._v(" "),s("li",[e._v("按顺序自动地执行滚动更新")])]),e._v(" "),s("p",[e._v("如果一个应用程序不需要稳定的网络标识，或者不需要按顺序部署、删除、增加副本，您应该考虑使用 Deployment 这类无状态（stateless）的控制器。")]),e._v(" "),s("h4",{attrs:{id:"创建headless-service"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#创建headless-service"}},[e._v("#")]),e._v(" 创建Headless Service")]),e._v(" "),s("p",[e._v("创建Statefulset需要一个Headless Service用于Pod访问")]),e._v(" "),s("h4",{attrs:{id:"创建statefulset"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#创建statefulset"}},[e._v("#")]),e._v(" 创建Statefulset")]),e._v(" "),s("p",[e._v("Statefulset的YAML定义与其他对象基本相同，主要有两个差异点：")]),e._v(" "),s("ul",[s("li",[e._v("serviceName指定了Statefulset使用哪个Headless Service，需要填写Headless Service的名称。")]),e._v(" "),s("li",[e._v("volumeClaimTemplates是用来申请持久化声明"),s("a",{attrs:{href:"https://support.huaweicloud.com/basics-cce/kubernetes_0030.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("PVC"),s("OutboundLink")],1),e._v("，这里定义了一个名为data的模板，它会为每个Pod创建一个PVC，storageClassName指定了持久化存储的类型，在"),s("a",{attrs:{href:"https://support.huaweicloud.com/basics-cce/kubernetes_0030.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("PV、PVC和StorageClass"),s("OutboundLink")],1),e._v("会详细介绍；volumeMounts是为Pod挂载存储。当然如果不需要存储的话可以删除volumeClaimTemplates和volumeMounts字段。")])]),e._v(" "),s("h4",{attrs:{id:"statefulset的网络标识"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#statefulset的网络标识"}},[e._v("#")]),e._v(" StatefulSet的网络标识")]),e._v(" "),s("p",[e._v("StatefulSet创建后，可以看下Pod是有固定名称的，那Headless Service是如何起作用的呢，那就是使用DNS，为Pod提供固定的域名，这样Pod间就可以使用域名访问，即便Pod被重新创建而导致Pod的IP地址发生变化，这个域名也不会发生变化。")]),e._v(" "),s("p",[e._v("Headless Service创建后，每个Pod的IP都会有下面格式的域名。")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("**<pod-name>.<svc-name>.<namespace>.svc.cluster.local**\n\n例如上面的三个Pod的域名就是：\n\n- nginx-0.nginx.default.svc.cluster.local\n- nginx-1.nginx.default.svc.cluster.local\n- nginx-2.nginx.default.svc.cluster.local\n\n实际访问时可以省略后面的**.<namespace>.svc.cluster.local**。\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br")])]),s("div",{staticClass:"language-shell line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[e._v("nslookup")]),e._v(" saber-db-0.saber-db\nnslookup: can"),s("span",{pre:!0,attrs:{class:"token string"}},[e._v("'t resolve '")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("null"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("': Name does not resolve\n\nName:      saber-db-0.saber-db\nAddress "),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("1")]),e._v(": "),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("100.64")]),e._v(".4.214 saber-db-0.saber-db.spring-blade.svc.cluster.local\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br")])]),s("h4",{attrs:{id:"statefulset存储状态"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#statefulset存储状态"}},[e._v("#")]),e._v(" StatefulSet存储状态")])])}),[],!1,null,null,null);s.default=l.exports}}]);